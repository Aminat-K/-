# -*- coding: utf-8 -*-
"""Амирханова_Аминат_802_vkr_telecom.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s0-knjq9x9IDYO2d3tFZAvDC4JkagKxy

# Сегментация клиентской базы телекоммуникационной компании

**Аналитическая задача** — провести анализ данных с целью выделения наиболее типичных групп клиентов и разработки предложений для каждой из групп.

## Описание данных
Каждый клиент описывается следующим набором признаков:
- `Возраст`, `Среднемесячный расход`, `Средняя продолжительность разговоров`, `Звонков днем за месяц`, `Звонков вечером за месяц`, `Звонков ночью за месяц`, `Звонки в другие города`, `Звонки в другие страны`, `Доля звонков на стационарные телефоны`, `Количество SMS за месяц`, `Дата подключения тарифа`.

## Примерный план по выполнению проекта

**Шаг 1.** Загрузка данных;

**Шаг 2.** Первичная обработка данных (при необходимости):
- скорректировать заголовки;
- скорректировать типы признаков;
- проверить наличие дублирующихся записей;
- проверить наличие аномальных значений;
- восстановить пропущенные значения;

**Шаг 3.** Добавление новых переменных:
- по значениям признака `Возраст` введите новую переменную `Возрастная категория`, принимающую значения "студент", "аспирант", "бизнесмен" и "знаток" по следующую правилу:

$$
\text{Возрастная категория} =
\left\{
\begin{array}{l}
\text{студент,} \quad \text{если Возраст } \in [19, 24];\\
\text{аспирант,} \quad \text{если Возраст } \in [25, 33];\\
\text{бизнесмен,} \quad \text{если Возраст } \in [34, 56];\\
\text{знаток,} \quad \text{если Возраст } \in [57, 70].
\end{array}
\right.
$$

- по значениям признака `Дата подключения тарифа` создайте признаки: `Год подключения`, `Месяц подключения`, `Дата подключения`;

**Шаг 3.** Провести исследовательский анализ данных:
- в разрезе значений признаков `Год подключения`, `Месяц подключения`, `Дата подключения` исследуйте:
    - динамику подключения к тарифам (количество клиентов). Постройте графики. В какой год, месяц и день подключались меньше/больше всего клиентов? Какие выводы можно сделать?
- в разрезе значений признака `Возрастная категория` исследуйте распределение признаков `Среднемесячный расход`, `Средняя продолжительность разговоров`, `Звонков днем за месяц`, `Звонков вечером за месяц`, `Звонков ночью за месяц`, `Звонки в другие города`, `Доля звонков на стационарные телефоны`, `Количество SMS за месяц`. Для каждого из признаков рассчитайте выборочное среднее, медиану и моду. Постройте графики. Какие выводы можно сделать о предпочтениях клиентов разных возрастных категорий в отношении используемых услуг (звонков и SMS; времени суток);
- клиенты каких возрастных категорий (ТОП-2):

    - больше всего в среднем в месяц тратят на оплату услуг связи;
    - больше всего тратят времени на общение в месяц днем, вечером и ночью;
    - больше всего по количеству звонков в месяц днем, вечером и ночью. Совпадают ли результаты с предыдущем пунктом;

- с помощью диаграмм рассеивания исследуейте зависимости между признаками `Среднемесячный расход`, `Средняя продолжительность разговоров`, `Звонков днем за месяц`, `Звонков вечером за месяц`, `Звонков ночью за месяц`, `Звонки в другие города`, `Доля звонков на стационарные телефоны`, `Количество SMS за месяц`. Какие выводы можно сделать?
"""



import pandas as pd
import numpy as np

from scipy.stats import shapiro
from scipy.stats import kstest
from scipy.stats import ks_2samp
from scipy.stats import anderson
from scipy.stats import jarque_bera

#тесты для проверки гипотезы о равенстве параметров распределений
from scipy.stats import ttest_ind
from scipy.stats import mannwhitneyu
from scipy.stats import kruskal

import datetime as dt
from scipy import stats

import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('/content/dataset_telecom.csv')
df.head(5)

df.info()

"""Данные загружены корректно. Однако имеется крайне небольшой процент пропусков, а также необходима  корректировка типов данных. Корректировка заголовков не требуется."""

#удаление пропущенных значений
df.dropna(inplace = True)

#проверка на наличие дублей
df.duplicated().sum()

df.info()

(4492-4430)/4492*100

df.columns

#преобразование типов:

df = df.astype({'Дата подключения тарифа' : 'datetime64'})

df.info()

from pandas.core.internals.base import T
#скорректировать типы признаков -- корректировка количественных признаков;

#напишем функцию для конвертации str -> float
def str_to_int(x : str) -> float:
    if x.isdigit():
        return float(x)
    else:
        return float(x.replace("'",''))

column = ['Звонков ночью за месяц',
          'Звонки в другие города',
          'Доля звонков на стационарные телефоны',
          'Количество SMS за месяц']

for col in column:
    df[col] = df[col].apply(str_to_int)

df.info()

"""После корректировки типов данных займемся аномальными значениями."""

df.describe()

from numpy.lib.function_base import percentile
# поиск аномальных значений

percentile = [0.01, 0.05, 0.25, 0.5, 0.75, 0.9 ,0.99]

df.describe(percentiles = percentile)

#обработка звонков в другие страны

df[df['Звонки в другие страны'] >= 2]

"""Звонков в другие страны немного, однако по ним высокий среднемесячный расход."""

#Удаляем звонки в другие страны построчно

df_country = df.loc[df['Звонки в другие страны'] >= 2]

#оставили тех, кто не пользуется или редко пользуется международной связью
df_not_country = df.loc[~(df['Звонки в другие страны'] >= 2)].drop(columns = 'Звонки в другие страны')

df_not_country

df_not_country.head(2)

# 2 линии нижнего и верхнего усов
#для подсчета значений нижнего и верхнего усов была предложена следующая функция
def calc_boxplot(df_col : pd.Series) -> tuple:

    """
    Функция для расчета значений нижнего и верхнего усов.
    На вход подается столбец датафрейма,
    на выходе кортеж: первый элемент -- нижний ус, второй элемент -- верхний ус
    """

    Q1, median, Q3 = np.percentile(np.asarray(df_col.dropna()), [25, 50, 75])
    IQR = Q3 - Q1
    loval = Q1 - 1.5 * IQR
    hival = Q3 + 1.5 * IQR
    wiskhi = np.compress(np.asarray(df_col.dropna()) <= hival, np.asarray(df_col.dropna()))
    wisklo = np.compress(np.asarray(df_col.dropna()) >= loval, np.asarray(df_col.dropna()))
    actual_hival = np.max(wiskhi)
    actual_loval = np.min(wisklo)
    return actual_loval, actual_hival #(нижний ус, верхний ус)

df_not_country.columns

cont_var = ['Возраст', 'Среднемесячный расход',
       'Средняя продолжительность разговоров', 'Звонков днем за месяц',
       'Звонков вечером за месяц', 'Звонков ночью за месяц',
       'Звонки в другие города', 'Доля звонков на стационарные телефоны',
       'Количество SMS за месяц']

#рассчитаем с помощью этой функции значения усов для исследуемых признаков

for col in cont_var:
    value_low, value_upper = calc_boxplot(df_not_country[col])
    print('Для признака {}: нижний ус -- {}; верхний ус -- {}.'.format(col, value_low, value_upper))

# 5. линии квантилей, усов и мод
# эти линии мы рисуем на плотности они будут вертикальными
# код предыдущих графиков без изменений

#для расчета квантилей воспользуемся методом np.percentile

fig, ax = plt.subplots(len(cont_var), 2, figsize = (14, 52)) # задаем сетку len(cont_var) на 2 -- 8 графиков

for index, col in enumerate(cont_var): #перебираем в цикле заголовки признаков `col` и сразу же генерируем номер рисунка `index`
    plt.subplot(len(cont_var), 2, 2*index + 1) #задаем рисунок с нужным нечетным номером (нумерация начинается с 1)
    ax = sns.boxplot(y = df_not_country[col]) #рисуем ящик
    plt.title("Ящик с усами \n для признака <<{}>>".format(col), fontsize = 10) #заголовок рисунка
    plt.ylabel('Количество', fontsize = 8) #подпись оси ординат
    plt.xlabel(col, fontsize = 8) #подпись оси абцисс
    value_low, value_upper = calc_boxplot(df_not_country[col])
    plt.axhline(value_low, #значение координаты по оси ординат -- горизонтальная линия имеет координаты (0, value_low)
                color = 'red', # цвет линии
                label = 'Нижний ус {}'.format(np.round(value_low,2)) #текст для легенды -- отображаем значение уса, округленное до 2 знаков
                )
    plt.axhline(value_upper, #значение координаты по оси ординат -- горизонтальная линия имеет координаты (0, value_upper)
                color = 'red', # цвет линии
                label = 'Верхний ус {}'.format(np.round(value_upper,2)) #текст для легенды -- отображаем значение уса, округленное до 2 знаков
                )

    plt.legend(loc='upper right') #отображаем легенду, принудительно размещая ее в правом верхнем углу

    #четные рисунки -- рисуем гистограммы и плотности
    plt.subplot(len(cont_var), 2, 2*index + 2)
    ax = sns.histplot(df_not_country[col], #признак
                      kde = True #для рисования функции плотности
                      )
    ax.set_xlabel(col, fontsize = 8) #подпись оси абцисс

    #ИЗМЕНЕНИЯ ТУТ
    #вначале рисуем усы на плотности в виде вертикальных линий -- метод axvline()

    value_low, value_upper = calc_boxplot(df_not_country[col])
    plt.axvline(value_low, #значение координаты по оси ординат -- горизонтальная линия имеет координаты (0, value_low)
                color = 'red', # цвет линии
                label = 'Нижний ус {}'.format(np.round(value_low,2)) #текст для легенды -- отображаем значение уса, округленное до 2 знаков
                )
    plt.axvline(value_upper, #значение координаты по оси ординат -- горизонтальная линия имеет координаты (0, value_upper)
                color = 'yellow', # цвет линии
                label = 'Верхний ус {}'.format(np.round(value_upper,2)) #текст для легенды -- отображаем значение уса, округленное до 2 знаков
                )

    plt.legend(loc='upper right') #отображаем легенду, принудительно размещая ее в правом верхнем углу

    #рисуем квантили
    #вначале считаем 1 и 99 квантили
    per_1 = np.percentile(df_not_country[col].dropna(), 1)
    per_99 = np.percentile(df_not_country[col].dropna(), 99)

    plt.axvline(per_1, #значение координаты по оси ординат -- вертикальная линия имеет координаты (0, per_1)
                color = 'green', # цвет линии
                label = '1-я квантиль {}'.format(np.round(per_1,2)) #текст для легенды -- отображаем значение квантиля, округленное до 2 знаков
                )
    plt.axvline(per_99, #значение координаты по оси абцисс -- вертикальная линия имеет координаты (0, per_99)
                color = 'black', # цвет линии
                label = '99-я квантиль {}'.format(np.round(per_99,2)) #текст для легенды -- отображаем значение квантиля, округленное до 2 знаков
                )

    plt.legend(loc='upper right') #отображаем легенду, принудительно размещая ее в правом верхнем углу
    #КОНЕЦ ИЗМЕНЕНИЙ

    plt.title("Гистограмма с плотностью \n для признака <<{}>>".format(col), fontsize = 10) #заголовок рисунка
    plt.ylabel('Количество', fontsize = 8) #подпись оси ординат
    plt.xlabel(col, fontsize = 8) #подпись оси абцисс

#линии нижнего и верхнего усов
#для подсчета значений нижнего и верхнего усов была предложена следующая функция
def calc_boxplot(df_not_country : pd.Series) -> tuple:

    """
    Функция для расчета значений нижнего и верхнего усов.
    На вход подается столбец датафрейма,
    на выходе кортеж: первый элемент -- нижний ус, второй элемент -- верхний ус
    """

    Q1, median, Q3 = np.percentile(np.asarray(df_not_country.dropna()), [25, 50, 75])
    IQR = Q3 - Q1
    loval = Q1 - 1.5 * IQR
    hival = Q3 + 1.5 * IQR
    wiskhi = np.compress(np.asarray(df_not_country.dropna()) <= hival, np.asarray(df_not_country.dropna()))
    wisklo = np.compress(np.asarray(df_not_country.dropna()) >= loval, np.asarray(df_not_country.dropna()))
    actual_hival = np.max(wiskhi)
    actual_loval = np.min(wisklo)
    return actual_loval, actual_hival #(нижний ус, верхний ус)

"""
*Таким образом, получаем следующую картину:*

*   Возраст - аномалий не обнаружено, но много записей с 19-20 летними,
*   Среднемесячный расход - аномалии от 1199,
*   Средняя продолжительность разговоров - аномалии от 11,
*   Звонков днем за месяц - аномалии от 113, но есть немного клиентов, которые совершают очень много звонков,
*   Звонков вечером за месяц - аномалий не обнаружено,
*   Звонков ночью за месяц - аномалии от 10 звонков, но есть небольшое количество пользователей, которые ночью совершают большое количество звонков,
*   Звонки в другие города - аномалии от 25,
*   Доля звонков на стационарные телефоны - аномалии от 32,
*   Количество SMS за месяц - аномалии от 75, но небольшое количество клиентов много отправляют SMS.
"""

filtered = """Среднемесячный расход > 1119 | Средняя продолжительность разговоров > 11 |
Звонков днем за месяц > 113 | Звонков ночью за месяц > 10 | Звонки в другие города > 25 | Доля звонков на стационарные телефоны > 32 |
Количество SMS за месяц > 75"""

# датасет по верхним усам. Видим, что теряется довольно значительный объем данных,
#поэтому в дальнейшем будем использовать датасет, обрезанный по 99 квантили
df_not_country[
    (df_not_country['Среднемесячный расход'] < 1119) &
    (df_not_country['Средняя продолжительность разговоров'] < 11) &
    (df_not_country['Звонков днем за месяц'] < 113) &
    (df_not_country['Звонков ночью за месяц'] < 10) &
    (df_not_country['Звонки в другие города'] < 25) &
     (df_not_country['Доля звонков на стационарные телефоны'] < 32) &
    (df_not_country['Количество SMS за месяц'] < 75)
    ]



#датасет по 99 квантили
df_work = df_not_country[
    (df_not_country['Среднемесячный расход'] < 3134) &
    (df_not_country['Средняя продолжительность разговоров'] < 11) &
    (df_not_country['Звонков днем за месяц'] < 346) &
    (df_not_country['Звонков ночью за месяц'] < 80) &
    (df_not_country['Звонки в другие города'] < 45) &
     (df_not_country['Доля звонков на стационарные телефоны'] < 32) &
    (df_not_country['Количество SMS за месяц'] < 125)
    ]

df_work.head(5)

#убеждаемся, что все в порядке и переходим к следующему шагу.
df_work.info()

"""> **Шаг 3.** Проводим исследовательский анализ данных.


"""

#проверка на перекрытие временного интервала
df_work['Дата подключения тарифа'].agg(['min', 'max'])

#генерирование новых признаков
df_work['Год подключения'] = df_work['Дата подключения тарифа'].dt.year
df_work['Месяц подключения'] = df_work['Дата подключения тарифа'].dt.strftime('%Y-%m')
df_work['Дата подключения'] = df_work['Дата подключения тарифа'].dt.date

#проверка
df_work[['Дата подключения тарифа', 'Год подключения', 'Месяц подключения', 'Дата подключения']].head(2)

df_count_client_year = df_work.groupby('Год подключения').\
agg(count_client = ('Год подключения','count')).\
reset_index()

ax = sns.barplot(data = df_count_client_year,
            x = 'Год подключения',
            y = 'count_client');
ax.set_xticklabels(ax.get_xticklabels(), rotation = 0, fontsize = 8)
plt.ylabel('')
plt.xlabel('')
for p in ax.patches:
        x=p.get_bbox().get_points()[:,0] #координаты для вставки текста
        y=p.get_bbox().get_points()[1,1] #координаты для вставки текста
        plt.annotate('{:.0f}'.format(p.get_height()), # вставка текста '{:.0f}'.format(p.get_height())   ----------исправлено ax -> plt
            (x.mean(), y), ha = 'center', va = 'bottom', fontsize = 10)
plt.show()

"""> Видим, что меньше всего люди подключались в 2015 году, а больше всего в 2017.

*   Новый пункт
*   Новый пункт

В целом, колебания незначительны.
"""

df_count_client_month = df_work.groupby('Месяц подключения').\
agg(count_client = ('Месяц подключения','count')).\
reset_index()

fig, ax = plt.subplots(figsize = (12, 6))

ax = sns.barplot(data = df_count_client_month,
            x = 'Месяц подключения',
            y = 'count_client');

ax.set_xticklabels(df_count_client_month['Месяц подключения'],
                   rotation = 90,
                   fontsize = 7);

"""> Видим, что меньше всего люди подключались в начале и конце года, а больше всего подключений приходится на конец лета-начало осени. Что, возможно, связано с началом учебного года."""

df_count_client_day = df_work.groupby('Дата подключения').\
agg(count_client = ('Дата подключения','count')).\
reset_index()

fig, ax = plt.subplots(figsize = (12, 6))

ax = sns.barplot(data = df_count_client_day,
            x = 'Дата подключения',
            y = 'count_client');

#ax.set_xticklabels(df_count_client_day['Дата подключения'],
#                   rotation = 90,
#                   fontsize = 7);

"""> *Вывод: видим, что динамика подлючения пользователей сохраняется по годам и месяцам, однако по дням график малоинформативен, хотя и на нем прослежтвается некая цикличность.*

> * Добавление новых переменных

по значениям признака `Возраст` введите новую переменную `Возрастная категория`, принимающую значения "студент", "аспирант", "бизнесмен" и "знаток" по следующую правилу:

$$
\text{Возрастная категория} =
\left\{
\begin{array}{l}
\text{студент,} \quad \text{если Возраст } \in [19, 24];\\
\text{аспирант,} \quad \text{если Возраст } \in [25, 33];\\
\text{бизнесмен,} \quad \text{если Возраст } \in [34, 56];\\
\text{знаток,} \quad \text{если Возраст } \in [57, 70].
\end{array}
\right.
$$
"""

def age_cat(age : int) -> str:
    if (age >= 19) & (age <= 24):
        return 'студент'
    elif (age >= 25) & (age <= 33):
        return 'аспирант'
    elif (age >= 34) & (age <= 56):
        return 'бизнесмен'
    else:
        return 'знаток'

df_work.loc[:,'Возрастная категория'] =  df_work['Возраст'].apply(age_cat)

df_work[['Возраст', 'Возрастная категория']]

df_work['Возрастная категория'].value_counts()

sns.countplot(y = 'Возрастная категория', data = df_work);

"""В разрезе значений признака Возрастная категория исследуем распределение признаков
- Среднемесячный расход,
- Средняя продолжительность разговоров,
- Звонков днем за месяц,
- Звонков вечером за месяц,
- Звонков ночью за месяц,
- Звонки в другие города,
-  Доля звонков на стационарные телефоны,
- Количество SMS за месяц.

Для каждого из признаков рассчитаем выборочное среднее, медиану и моду. Построим графики.
"""

df_work.groupby('Возрастная категория')[['Возрастная категория' , 'Среднемесячный расход',
                                         'Средняя продолжительность разговоров',
                                         'Звонков днем за месяц',
                                         'Звонков вечером за месяц',
                                         'Звонков ночью за месяц',
                                         'Звонки в другие города',
                                         'Доля звонков на стационарные телефоны',
                                         'Количество SMS за месяц']].mean().round(2)

df_work.groupby('Возрастная категория')[['Возрастная категория' , 'Среднемесячный расход',
                                         'Средняя продолжительность разговоров',
                                         'Звонков днем за месяц',
                                         'Звонков вечером за месяц',
                                         'Звонков ночью за месяц',
                                         'Звонки в другие города',
                                         'Доля звонков на стационарные телефоны',
                                         'Количество SMS за месяц']].median().round(2)



df_work_asp = df_work[df_work['Возрастная категория'] == 'аспирант']
df_work_asp.head(5)

mode_var = ['Возрастная категория' , 'Среднемесячный расход',
            'Средняя продолжительность разговоров',
            'Звонков днем за месяц',
            'Звонков вечером за месяц',
            'Звонков ночью за месяц',
            'Звонки в другие города',
            'Доля звонков на стационарные телефоны','Количество SMS за месяц']

for col in mode_var:
    print(df_work_asp[col].mode()[0])

df_work_asp.describe()

df_work_bus = df_work[df_work['Возрастная категория'] == 'бизнесмен']
df_work_bus.describe()

for col in mode_var:
    print(df_work_bus[col].mode()[0])

df_work_bus[['Возрастная категория' , 'Среднемесячный расход',
            'Средняя продолжительность разговоров',
            'Звонков днем за месяц',
            'Звонков вечером за месяц',
            'Звонков ночью за месяц',
            'Звонки в другие города',
            'Доля звонков на стационарные телефоны','Количество SMS за месяц']].mode()

df_work_zn = df_work[df_work['Возрастная категория'] == 'знаток']
df_work_zn.describe()

for col in mode_var:
    print(df_work_zn[col].mode()[0])

df_work_zn[['Возрастная категория' , 'Среднемесячный расход',
            'Средняя продолжительность разговоров',
            'Звонков днем за месяц',
            'Звонков вечером за месяц',
            'Звонков ночью за месяц',
            'Звонки в другие города',
            'Доля звонков на стационарные телефоны','Количество SMS за месяц']].mode()

df_work_st = df_work[df_work['Возрастная категория'] == 'студент']
df_work_st.describe()

for col in mode_var:
    print(df_work_st[col].mode()[0])

sns.histplot(data = df_work[df_work['Возрастная категория'] == 'студент'],
             x = 'Среднемесячный расход')

sns.histplot(data = df_work[df_work['Возрастная категория'] == 'аспирант'],
             x = 'Среднемесячный расход')

sns.histplot(data = df_work[df_work['Возрастная категория'] == 'бизнесмен'],
             x = 'Среднемесячный расход')

sns.histplot(data = df_work[df_work['Возрастная категория'] == 'знаток'],
             x = 'Среднемесячный расход')

#выбранные столбцы
column = ['Среднемесячный расход', 'Средняя продолжительность разговоров',
          'Звонков днем за месяц', 'Звонков вечером за месяц',
          'Звонков ночью за месяц', 'Доля звонков на стационарные телефоны',
          'Количество SMS за месяц']

list_colors = ['red', 'green', 'black', 'blue']

#сетка 7 на 4: в одной строке для каждой возрастной категории будет по графику
fig, ax = plt.subplots(7,4, figsize = (24, 36)) #

index = 0
for col in column:
    for index_color, category in enumerate(df_work["Возрастная категория"].unique()):
        index += 1
        plt.subplot(7, 4, index)
        ax = sns.histplot(data = df_work,
                          x = df_work[df_work["Возрастная категория"] == category][col],
                          color = list_colors[index_color]);
        ax.set_title(f'Возрастная категория <<{category}>>')

df_work.columns

sns.barplot(data = df_work, x = 'Возрастная категория', y= 'Среднемесячный расход')

sns.barplot(data = df_work, x = 'Возрастная категория', y= 'Средняя продолжительность разговоров')

sns.barplot(data = df_work, x = 'Возрастная категория', y= 'Звонков днем за месяц')

sns.barplot(data = df_work, x = 'Возрастная категория', y= 'Звонков вечером за месяц')

sns.barplot(data = df_work, x = 'Возрастная категория', y= 'Звонков ночью за месяц')



sns.barplot(data = df_work, x = 'Возрастная категория', y= 'Звонки в другие города')

sns.barplot(data = df_work, x = 'Возрастная категория', y= 'Доля звонков на стационарные телефоны')

sns.barplot(data = df_work, x = 'Возрастная категория', y= 'Количество SMS за месяц')

#делаем графики цветными
#если нужно в разрезе какой-либо категориальной переменной
sns.pairplot(data = df_work,
             vars = ['Среднемесячный расход',
                     'Средняя продолжительность разговоров',
                     'Звонков днем за месяц',
                     'Звонков вечером за месяц',
                     'Звонков ночью за месяц'],
             hue = 'Возрастная категория')

#делаем графики цветными
#если нужно в разрезе какой-либо категориальной переменной
sns.pairplot(data = df_work,
             vars = ['Звонки в другие города',
                       'Доля звонков на стационарные телефоны',
                       'Количество SMS за месяц'],
             hue = 'Возрастная категория')

"""> Анализ графиков, представленных выше, говорит о том, что в целом "бизнесмены" более активно пользуются связью. За исключением SMS.

- Клиенты каких возрастных категорий (ТОП-2):

    - больше всего в среднем в месяц тратят на оплату услуг связи;
    - больше всего тратят времени на общение в месяц днем, вечером и ночью;
    - больше всего по количеству звонков в месяц днем, вечером и ночью.
"""

df_work_asp[['Среднемесячный расход']].sort_values



"""

> Построим диаграммы рассеивания для исследования зависимости между признаками `Среднемесячный расход`, `Средняя продолжительность разговоров`, `Звонков днем за месяц`, `Звонков вечером за месяц`, `Звонков ночью за месяц`, `Звонки в другие города`, `Доля звонков на стационарные телефоны`, `Количество SMS за месяц`."""

column = ['Среднемесячный расход', 'Средняя продолжительность разговоров',
          'Звонков днем за месяц', 'Звонков вечером за месяц',
          'Звонков ночью за месяц']

list_colors = ['red', 'green', 'black', 'blue', 'orange']
fig, ax = plt.subplots(5,4, figsize = (24, 36))

index = 0
for index_color, col in enumerate(column):
    set_columns = set(column).difference(set([col]))
    for c in set_columns:
        index += 1
        plt.subplot(5, 4, index)
        sns.scatterplot(data = df_work,
                x = c,
                y = col,
                color = list_colors[index_color]);

#по каждой переменной свой цвет

column = ['Среднемесячный расход', 'Средняя продолжительность разговоров',
          'Звонков днем за месяц', 'Звонков вечером за месяц',
          'Звонков ночью за месяц', 'Звонки в другие города',
          'Доля звонков на стационарные телефоны', 'Количество SMS за месяц']

list_colors = ['red', 'green', 'black', 'blue', 'orange', 'brown', 'grey', 'pink']
fig, ax = plt.subplots(8, 7, figsize = (24, 36))

index = 0
for index_color, col in enumerate(column):
    set_columns = set(column).difference(set([col]))
    for c in set_columns:
        index += 1
        plt.subplot(8, 7, index)
        sns.scatterplot(data = df_work,
                x = c,
                y = col,
                color = list_colors[index_color]);

"""- Клиенты каких возрастных категорий (ТОП-2):

    - больше всего в среднем в месяц тратят на оплату услуг связи ;
    - больше всего тратят времени на общение в месяц днем, вечером и ночью;
    - больше всего по количеству звонков в месяц днем, вечером и ночью.
"""

df_work.groupby('Возрастная категория')[['Возрастная категория' , 'Среднемесячный расход',
                                         'Средняя продолжительность разговоров',
                                         'Звонков днем за месяц',
                                         'Звонков вечером за месяц',
                                         'Звонков ночью за месяц']].max()

df_work_asp[['Среднемесячный расход']].sort_values(by = 'Среднемесячный расход', ascending = False)[:2]

df_work_bus[['Среднемесячный расход']].sort_values(by = 'Среднемесячный расход', ascending = False)[:2]

df_work_st[['Среднемесячный расход']].sort_values(by = 'Среднемесячный расход', ascending = False)[:2]

df_work_zn[['Среднемесячный расход']].sort_values(by = 'Среднемесячный расход', ascending = False)[:2]

"""> Больше всего в среднем в месяц тратят на оплату услуг связи - "знатоки"
"""

df_work_asp[['Средняя продолжительность разговоров']].sort_values(by = 'Средняя продолжительность разговоров', ascending = False)[:2]

df_work_st[['Средняя продолжительность разговоров']].sort_values(by = 'Средняя продолжительность разговоров', ascending = False)[:2]

df_work_bus[['Средняя продолжительность разговоров']].sort_values(by = 'Средняя продолжительность разговоров', ascending = False)[:2]

df_work_zn[['Средняя продолжительность разговоров']].sort_values(by = 'Средняя продолжительность разговоров', ascending = False)[:2]

"""> Больше всего тратят времени на общение - бизнесмены и знатоки, хотя и
аспиранты отстают от них незначительно.
"""

df_work_st[['Звонков днем за месяц']].sort_values(by = 'Звонков днем за месяц', ascending = False)[:2]

df_work_zn[['Звонков днем за месяц']].sort_values(by = 'Звонков днем за месяц', ascending = False)[:2]

df_work_asp[['Звонков днем за месяц']].sort_values(by = 'Звонков днем за месяц', ascending = False)[:2]

df_work_bus[['Звонков днем за месяц']].sort_values(by = 'Звонков днем за месяц', ascending = False)[:2]

"""Звонков днем за месяц больше всех совершили бизнесмены."""

df_work_bus[['Звонков вечером за месяц']].sort_values(by = 'Звонков вечером за месяц', ascending = False)[:2]

df_work_asp[['Звонков вечером за месяц']].sort_values(by = 'Звонков вечером за месяц', ascending = False)[:2]

df_work_st[['Звонков вечером за месяц']].sort_values(by = 'Звонков вечером за месяц', ascending = False)[:2]

df_work_zn[['Звонков вечером за месяц']].sort_values(by = 'Звонков вечером за месяц', ascending = False)[:2]

"""Вечером максимальное количество звонков (за исключением студентов) совпало."""

df_work_bus[['Звонков ночью за месяц']].sort_values(by = 'Звонков ночью за месяц', ascending = False)[:2]

df_work_zn[['Звонков ночью за месяц']].sort_values(by = 'Звонков ночью за месяц', ascending = False)[:2]

df_work_asp[['Звонков ночью за месяц']].sort_values(by = 'Звонков ночью за месяц', ascending = False)[:2]

df_work_st[['Звонков ночью за месяц']].sort_values(by = 'Звонков ночью за месяц', ascending = False)[:2]

"""Чаще всего по ночам звонят именно аспиранты."""

